

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、引言1.什么是JVM（1）定义Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） （2）好处 一次编写，到处运行  自动内存管理，垃圾回收机制 数组下标越界检查 多态  （3）比较JVM JRE JDK的区别  2.学习JVM有什么用 面试  理解底层的实现原理  中高级程序员的必备技能  3.常见的JVM 4.学习路线 二、内存结构1.程序计数">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2022/03/31/JVM/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、引言1.什么是JVM（1）定义Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） （2）好处 一次编写，到处运行  自动内存管理，垃圾回收机制 数组下标越界检查 多态  （3）比较JVM JRE JDK的区别  2.学习JVM有什么用 面试  理解底层的实现原理  中高级程序员的必备技能  3.常见的JVM 4.学习路线 二、内存结构1.程序计数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331132507437.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331132659550.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331132719037.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331133023805.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331133433749.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331133516870.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331133834902.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331134651233.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331134733782.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331135147613.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140242903.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140800465.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140812348.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140826328.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140838277.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331143701259.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331143752654.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331150420834.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331150910460.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331151808232.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331151949071.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152321558.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152205873.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152655339.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152718843.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152757229.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152821640.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152847522.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152942849.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331153400159.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331153719810.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331154018638.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331154338363.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331154506276.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161535710.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161638986.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161652431.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161706231.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161751823.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161853706.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162021179.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162129796.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162157975.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162244377.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162526264.png">
<meta property="article:published_time" content="2022-03-31T08:55:56.838Z">
<meta property="article:modified_time" content="2022-03-31T08:59:39.292Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331132507437.png">
  
  
  <title>JVM - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-31 16:55" pubdate>
        2022年3月31日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      136 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM</h1>
            
            <div class="markdown-body">
              <h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><h2 id="1-什么是JVM"><a href="#1-什么是JVM" class="headerlink" title="1.什么是JVM"></a>1.什么是JVM</h2><h3 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境）</p>
<h3 id="（2）好处"><a href="#（2）好处" class="headerlink" title="（2）好处"></a>（2）好处</h3><ul>
<li>一次编写，到处运行 </li>
<li>自动内存管理，垃圾回收机制</li>
<li>数组下标越界检查</li>
<li>多态</li>
</ul>
<h3 id="（3）比较"><a href="#（3）比较" class="headerlink" title="（3）比较"></a>（3）比较</h3><p>JVM JRE JDK的区别</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331132507437.png" srcset="/img/loading.gif" lazyload alt="image-20220331132507437"></p>
<h2 id="2-学习JVM有什么用"><a href="#2-学习JVM有什么用" class="headerlink" title="2.学习JVM有什么用"></a>2.学习JVM有什么用</h2><ul>
<li>面试 </li>
<li>理解底层的实现原理 </li>
<li>中高级程序员的必备技能</li>
</ul>
<h2 id="3-常见的JVM"><a href="#3-常见的JVM" class="headerlink" title="3.常见的JVM"></a>3.常见的JVM</h2><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331132659550.png" srcset="/img/loading.gif" lazyload alt="image-20220331132659550"></p>
<h2 id="4-学习路线"><a href="#4-学习路线" class="headerlink" title="4.学习路线"></a>4.学习路线</h2><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331132719037.png" srcset="/img/loading.gif" lazyload alt="image-20220331132719037"></p>
<h1 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h1><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331133023805.png" srcset="/img/loading.gif" lazyload alt="image-20220331133023805"></p>
<h3 id="（1）定义-1"><a href="#（1）定义-1" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>Program Counter Register 程序计数器（寄存器）</p>
<h3 id="（2）作用：是记住下一条jvm指令的执行地址"><a href="#（2）作用：是记住下一条jvm指令的执行地址" class="headerlink" title="（2）作用：是记住下一条jvm指令的执行地址"></a>（2）作用：是记住下一条jvm指令的执行地址</h3><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331133433749.png" srcset="/img/loading.gif" lazyload alt="image-20220331133433749"></p>
<h3 id="（3）特点："><a href="#（3）特点：" class="headerlink" title="（3）特点："></a>（3）特点：</h3><ul>
<li>是线程私有的 <ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代 码 </li>
<li>程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通 过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li>不会存在内存溢出</li>
</ul>
<h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h2><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331133516870.png" srcset="/img/loading.gif" lazyload alt="image-20220331133516870"></p>
<h3 id="（1）定义-2"><a href="#（1）定义-2" class="headerlink" title="（1）定义"></a>（1）定义</h3><ul>
<li>每个线程运行需要的内存空间，称为虚拟机栈 </li>
<li>每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存 </li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li>
</ul>
<h3 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        method1();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331133834902.png" srcset="/img/loading.gif" lazyload alt="image-20220331133834902"></p>
<h3 id="（3）问题辨析"><a href="#（3）问题辨析" class="headerlink" title="（3）问题辨析"></a>（3）问题辨析</h3><ol>
<li><p>垃圾回收是否涉及栈内存？ </p>
<ul>
<li>不需要。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所 以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li><p>栈内存的分配越大越好吗？ </p>
<ul>
<li>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越 少。</li>
</ul>
</li>
<li><p>方法内的局部变量是否是线程安全的？</p>
<ul>
<li><p>如果方法内局部变量没有逃离方法的作用范围，则是线程安全的 </p>
</li>
<li><p>如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题</p>
</li>
</ul>
</li>
</ol>
<h3 id="（4）栈内存溢出"><a href="#（4）栈内存溢出" class="headerlink" title="（4）栈内存溢出"></a>（4）栈内存溢出</h3><p>Java.lang.stackOverflowError 栈内存溢出</p>
<p>发生原因：</p>
<ul>
<li>栈帧过多导致栈内存溢出 （无限递归）</li>
<li>栈帧过大导致栈内存溢出</li>
</ul>
<h3 id="（5）线程运行诊断"><a href="#（5）线程运行诊断" class="headerlink" title="（5）线程运行诊断"></a>（5）线程运行诊断</h3><p>案例1： Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p>
<ul>
<li>top命令，查看是哪个进程占用CPU过高 </li>
<li>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是 哪个线程占用CPU过高 </li>
<li>jstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找 出的线程id是16进制的，需要转换</li>
</ul>
<p>案例2：程序运行很长时间没有结果</p>
<h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331134651233.png" srcset="/img/loading.gif" lazyload alt="image-20220331134651233"></p>
<p>一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作 系统底层交互，所以需要用到本地方法</p>
<h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h2><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331134733782.png" srcset="/img/loading.gif" lazyload alt="image-20220331134733782"></p>
<h3 id="（1）定义-3"><a href="#（1）定义-3" class="headerlink" title="（1）定义"></a>（1）定义</h3><ul>
<li>通过new关键字创建的对象都会被放在堆内存</li>
</ul>
<h3 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h3><ul>
<li>所有线程共享，堆内存中的对象都需要考虑线程安全问题 </li>
<li>有垃圾回收机制</li>
</ul>
<h3 id="（3）堆内存溢出"><a href="#（3）堆内存溢出" class="headerlink" title="（3）堆内存溢出"></a>（3）堆内存溢出</h3><ul>
<li>java.lang.OutofMemoryError ：java heap space. 堆内存溢出</li>
</ul>
<h3 id="（4）堆内存诊断"><a href="#（4）堆内存诊断" class="headerlink" title="（4）堆内存诊断"></a>（4）堆内存诊断</h3><ul>
<li>jps ：查看当前系统中有哪些 java 进程</li>
<li>jmap ：查看堆内存占用情况 jmap - heap 进程id</li>
<li>jconsole ：图形界面的，多功能的监测工具，可以连续监测</li>
<li>jvirsalvm</li>
</ul>
<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331135147613.png" srcset="/img/loading.gif" lazyload alt="image-20220331135147613"></p>
<h3 id="（1）定义-4"><a href="#（1）定义-4" class="headerlink" title="（1）定义"></a>（1）定义</h3><ul>
<li>方法区与java堆一样，是各个线程共享的内存区域</li>
<li>方法区在jvm启动的时候被创建，并且它的实际物理内存空间和java堆区一样都是可以不连续的</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</li>
<li>方法区的大小，决定了系统可以保留多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机也会抛出内存溢出错误</li>
<li>关闭jvm就会释放这个区域的内存</li>
</ul>
<h3 id="（2）组成"><a href="#（2）组成" class="headerlink" title="（2）组成"></a>（2）组成</h3><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140242903.png" srcset="/img/loading.gif" lazyload alt="image-20220331140242903"></p>
<h3 id="（3）方法区内存溢出"><a href="#（3）方法区内存溢出" class="headerlink" title="（3）方法区内存溢出"></a>（3）方法区内存溢出</h3><ul>
<li>1.8以前会导致永久代内存溢出 </li>
<li>1.8以后会导致元空间内存溢出</li>
</ul>
<h3 id="（4）常量池"><a href="#（4）常量池" class="headerlink" title="（4）常量池"></a>（4）常量池</h3><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p>
<p>通过反编译来查看类的信息</p>
<ul>
<li><p>获得对应类的.class文件</p>
</li>
<li><p>在JDK对应的bin目录下运行cmd，也可以在IDEA控制台输入</p>
</li>
<li><p>输入 javac 对应类的绝对路径</p>
</li>
<li><p>输入完成后，对应的目录下就会出现类的.class文件</p>
</li>
<li><p>在控制台输入 javap -v 类的绝对路径</p>
</li>
</ul>
<p>然后能在控制台看到反编译以后类的信息了</p>
<ul>
<li>类的基本信息</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140800465.png" srcset="/img/loading.gif" lazyload alt="image-20220331140800465"></p>
<ul>
<li>常量池</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140812348.png" srcset="/img/loading.gif" lazyload alt="image-20220331140812348"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140826328.png" srcset="/img/loading.gif" lazyload alt="image-20220331140826328"></p>
<ul>
<li>虚拟机中执行编译的方法（框内的是真正编译执行的内容，#号的内容需要在常量池中查找）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331140838277.png" srcset="/img/loading.gif" lazyload alt="image-20220331140838277"></p>
<h3 id="（5）运行时常量池"><a href="#（5）运行时常量池" class="headerlink" title="（5）运行时常量池"></a>（5）运行时常量池</h3><ul>
<li>常量池： 就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法 名、参数类型、字面量信息 </li>
<li>运行时常量池：常量池是.class文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的 符号地址变为真实地址</li>
</ul>
<h3 id="（6）StringTable"><a href="#（6）StringTable" class="headerlink" title="（6）StringTable"></a>（6）StringTable</h3><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，还没有成为java字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">0: ldc 			<span class="hljs-comment">#2 			// String a</span><br>2: astore_1<br>3: ldc 			<span class="hljs-comment">#3 			// String b</span><br>5: astore_2<br>6: ldc 			<span class="hljs-comment">#4 			// String ab</span><br>8: astore_3<br>9: <span class="hljs-built_in">return</span><br></code></pre></td></tr></table></figure>

<ul>
<li>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，并放入串池中（hashtable结构 不可扩容）</li>
<li>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</li>
<li>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</li>
<li>最终StringTable [“a”, “b”, “ab”]</li>
</ul>
<p>注意：字符串对象的创建都是懒惰的，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2） 时，该字符串才会被创建并放入串池中。</p>
<p>使用拼接字符串变量对象创建字符串的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">//拼接字符串对象来创建新的字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ab2</span> <span class="hljs-operator">=</span> a+b;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"> Code:<br> stack=2, locals=5, args_size=1<br> 0: ldc <span class="hljs-comment">#2 // String a</span><br> 2: astore_1<br> 3: ldc <span class="hljs-comment">#3 // String b</span><br> 5: astore_2<br> 6: ldc <span class="hljs-comment">#4 // String ab</span><br> 8: astore_3<br> 9: new <span class="hljs-comment">#5 // class java/lang/StringBuilder</span><br> 12: dup<br> 13: invokespecial <span class="hljs-comment">#6 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br> 16: aload_1<br> 17: invokevirtual <span class="hljs-comment">#7 // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br> 20: aload_2<br> 21: invokevirtual <span class="hljs-comment">#7 // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br> 24: invokevirtual <span class="hljs-comment">#8 // Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br>ing;<br> 27: astore 4<br> 29: <span class="hljs-built_in">return</span><br></code></pre></td></tr></table></figure>

<p>通过拼接的方式来创建字符串的过程是：StringBuilder().append(“a”).append(“b”).toString()</p>
<p>最后的toString方法的返回值是一个新的字符串，但字符串的值和拼接的字符串一致，但是两个不同的字符 串，一个存在于串池之中，一个存在于堆内存之中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab2</span> <span class="hljs-operator">=</span> a+b;<br><span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br>System.out.println(ab == ab2);<br><br></code></pre></td></tr></table></figure>

<p>使用拼接字符串常量对象的方法创建字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ab2</span> <span class="hljs-operator">=</span> a+b;<br>        <span class="hljs-comment">//使用拼接字符串的方法创建字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ab3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"> Code:<br> stack=2, locals=6, args_size=1<br> 0: ldc <span class="hljs-comment">#2 // String a</span><br> 2: astore_1<br> 3: ldc <span class="hljs-comment">#3 // String b</span><br> 5: astore_2<br> 6: ldc <span class="hljs-comment">#4 // String ab</span><br> 8: astore_3<br> 9: new <span class="hljs-comment">#5 // class java/lang/StringBuilder</span><br> 12: dup<br> 13: invokespecial <span class="hljs-comment">#6 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br> 16: aload_1<br> 17: invokevirtual <span class="hljs-comment">#7 // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br> 20: aload_2<br> 21: invokevirtual <span class="hljs-comment">#7 // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br> 24: invokevirtual <span class="hljs-comment">#8 // Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br>ing;<br> 27: astore 4<br> //ab3初始化时直接从串池中获取字符串<br> 29: ldc <span class="hljs-comment">#4 // String ab</span><br> 31: astore 5<br> 33: <span class="hljs-built_in">return</span><br></code></pre></td></tr></table></figure>

<ul>
<li>使用拼接字符串常量的方法来创建新的字符串时，因为内容是常量，javac在编译期会进行优化，结果已 在编译期确定为ab，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以 进行的操作和 ab &#x3D; “ab” 一致。 </li>
<li>使用拼接字符串变量的方法来创建新的字符串时，因为内容是变量，只能在运行期确定它的值，所以需要 使用StringBuilder来创建</li>
</ul>
<h4 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h4><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功 </li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回串池中的字符串对象</p>
<p>注意：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个 对象</p>
<p>例1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">st2</span> <span class="hljs-operator">=</span> str.intern();<br>        <span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span><br>        System.out.println(str == st2);<br>        System.out.println(str == str3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <span class="hljs-comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>         <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>         <span class="hljs-comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str.intern();<br>         <span class="hljs-comment">//false</span><br>        System.out.println(str == str2);<br>         <span class="hljs-comment">//false</span><br>        System.out.println(str == str3);<br>         <span class="hljs-comment">//true</span><br>        System.out.println(str2 == str3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中 </p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中 </li>
<li>如果有该字符串对象，则放入失败 无论放入是否成功，都会返回串池中的字符串对象</li>
</ul>
<p>注意：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象都不是同一个对象</p>
<h3 id="（7）-StringTable-特性"><a href="#（7）-StringTable-特性" class="headerlink" title="（7） StringTable 特性"></a>（7） StringTable 特性</h3><ul>
<li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象 </li>
<li>利用串池的机制，来避免重复创建字符串对象 </li>
<li>字符串变量拼接的原理是StringBuilder </li>
<li>字符串常量拼接的原理是编译器优化 </li>
<li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中 </li>
<li>注意：无论是串池还是堆里面的字符串，都是对象</li>
</ul>
<h3 id="（8）StringTable-位置"><a href="#（8）StringTable-位置" class="headerlink" title="（8）StringTable 位置"></a>（8）StringTable 位置</h3><ul>
<li>jdk6以前，字符串常量池存放在永久代</li>
<li>jdk7之后，字符串常量池的位置调整到java堆中</li>
<li>jdk8加入元空间，字符串常量池在堆内</li>
</ul>
<h3 id="（9）StringTable-垃圾回收"><a href="#（9）StringTable-垃圾回收" class="headerlink" title="（9）StringTable 垃圾回收"></a>（9）StringTable 垃圾回收</h3><p>StringTable在内存紧张时，会发生垃圾回收</p>
<h3 id="（10）StringTable-性能调优"><a href="#（10）StringTable-性能调优" class="headerlink" title="（10）StringTable 性能调优"></a>（10）StringTable 性能调优</h3><p>因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串 池所需要的时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:StringTableSize=xxxx<br></code></pre></td></tr></table></figure>

<p>考虑是否需要将字符串对象入池</p>
<p>可以通过intern方法减少重复入池</p>
<h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h2><h3 id="（1）定义-5"><a href="#（1）定义-5" class="headerlink" title="（1）定义"></a>（1）定义</h3><ul>
<li>属于操作系统，常见于NIO操作时，用于数据缓冲区 </li>
<li>分配回收成本较高，但读写性能高 </li>
<li>不受JVM内存回收管理</li>
</ul>
<h3 id="（2）文件读写流程"><a href="#（2）文件读写流程" class="headerlink" title="（2）文件读写流程"></a>（2）文件读写流程</h3><p>未使用DirectBuffer</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331143701259.png" srcset="/img/loading.gif" lazyload alt="image-20220331143701259"></p>
<p>使用了DirectBuffer</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331143752654.png" srcset="/img/loading.gif" lazyload alt="image-20220331143752654"></p>
<p>直接内存是操作系统和Java代码都可以访问的一块区域，无需将代码从系统内存复制到Java堆内存，从而提高 了效率</p>
<h3 id="（3）释放原理"><a href="#（3）释放原理" class="headerlink" title="（3）释放原理"></a>（3）释放原理</h3><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过unsafe.freeMemory来手动释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_1M);<br></code></pre></td></tr></table></figure>

<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p>allocateDirect的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocateDirect</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br> 	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectByteBuffer</span>(capacity);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>DirectByteBuffer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-type">int</span> cap) &#123; <span class="hljs-comment">// package-private</span><br><br>     <span class="hljs-built_in">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> VM.isDirectMemoryPageAligned();<br>     <span class="hljs-type">int</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> Bits.pageSize();<br>     <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-type">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>     Bits.reserveMemory(size, cap);<br>     <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">try</span> &#123;<br>     	base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span><br>     &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>         Bits.unreserveMemory(size, cap);<br>         <span class="hljs-keyword">throw</span> x;<br>     &#125;<br>     unsafe.setMemory(base, size, (<span class="hljs-type">byte</span>) <span class="hljs-number">0</span>);<br>     <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>         <span class="hljs-comment">// Round up to page boundary</span><br>         address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>     	address = base;<br>     &#125;<br>     cleaner = Cleaner.create(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deallocator</span>(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引</span><br>     att = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里 是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clean</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span> (remove(<span class="hljs-built_in">this</span>)) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>         	<span class="hljs-built_in">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span><br>         &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;<br>         	AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>         <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>             <span class="hljs-keyword">if</span> (System.err != <span class="hljs-literal">null</span>) &#123;<br>             	(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>             &#125;<br>             System.exit(<span class="hljs-number">1</span>);<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>         &#125;<br>     &#125;);<br> &#125;<br><br></code></pre></td></tr></table></figure>

<p>对应对象的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// Paranoia</span><br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br>     unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span><br>     address = <span class="hljs-number">0</span>;<br>     Bits.unreserveMemory(size, capacity);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（4）分配和回收原理"><a href="#（4）分配和回收原理" class="headerlink" title="（4）分配和回收原理"></a>（4）分配和回收原理</h3><ul>
<li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li>
<li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么 会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li>
</ul>
<h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><h3 id="（1）引用计数法"><a href="#（1）引用计数法" class="headerlink" title="（1）引用计数法"></a>（1）引用计数法</h3><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331150420834.png" srcset="/img/loading.gif" lazyload alt="image-20220331150420834"></p>
<h3 id="（2）可达性分析算法"><a href="#（2）可达性分析算法" class="headerlink" title="（2）可达性分析算法"></a>（2）可达性分析算法</h3><ol>
<li><p>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象 </p>
</li>
<li><p>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收 </p>
</li>
<li><p>可以作为GC Root的对象</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象。　 </p>
</li>
<li><p>方法区中类静态属性引用的对象 </p>
</li>
<li><p>方法区中常量引用的对象 </p>
</li>
<li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p>
</li>
</ul>
</li>
</ol>
<h3 id="（3）五种引用"><a href="#（3）五种引用" class="headerlink" title="（3）五种引用"></a>（3）五种引用</h3><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331150910460.png" srcset="/img/loading.gif" lazyload alt="image-20220331150910460"></p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul>
<li>只有GC Root都不引用该对象时，才会回收强引用对象</li>
<li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li>
</ul>
<h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4><ul>
<li>当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象</li>
<li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li>
</ul>
<p>软引用的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4M</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>        <span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>        List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4M]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，软引用本身不会被清理</p>
<p>如果想要清理软引用，需要使用引用队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4M</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>        <span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span><br>        ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>        <span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>        List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4M]);<br>        <span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span><br>        Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span>(poll != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span><br>            list.remove(poll);<br>            <span class="hljs-comment">//移动到引用队列中的下一个元素</span><br>            poll = queue.poll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大概思路为：查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集 合）</p>
<h4 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h4><ul>
<li>只有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用所引用的对象 </li>
<li>如上图如果B对象不再引用A3对象，则A3对象会被回收 </li>
<li>弱引用的使用和软引用类似，只是将 SoftReference 换为了 WeakReference</li>
</ul>
<h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h4><ul>
<li>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法 </li>
<li>虚引用的一个体现是释放直接内存所分配的内存，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象 Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存 </li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。 这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<h4 id="终结器引用（FinalReference）"><a href="#终结器引用（FinalReference）" class="headerlink" title="终结器引用（FinalReference）"></a>终结器引用（FinalReference）</h4><ul>
<li>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将 终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize 方法。调用以后，该对象就可以被垃圾回收了 </li>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所 引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h4 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h4><ul>
<li>软引用和弱引用可以配合引用队列 </li>
<li>在弱引用和虚引用所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软&#x2F; 弱引用对象 </li>
<li>虚引用和终结器引用必须配合引用队列</li>
<li>虚引用和终结器引用在使用时会关联一个引用队列</li>
</ul>
<h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h2><h3 id="（1）标记-清除"><a href="#（1）标记-清除" class="headerlink" title="（1）标记-清除"></a>（1）标记-清除</h3><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331151808232.png" srcset="/img/loading.gif" lazyload alt="image-20220331151808232"></p>
<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>​    标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后 垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存 的时候，会直接覆盖这段内存</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>​    速度较快</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>​    容易产生大量的内存碎片，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm 启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h3 id="（2）标记-整理"><a href="#（2）标记-整理" class="headerlink" title="（2）标记-整理"></a>（2）标记-整理</h3><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331151949071.png" srcset="/img/loading.gif" lazyload alt="image-20220331151949071"></p>
<h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>​    标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免 因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>​    没有内存碎片</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>​    速度慢</p>
<h3 id="（3）复制"><a href="#（3）复制" class="headerlink" title="（3）复制"></a>（3）复制</h3><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152321558.png" srcset="/img/loading.gif" lazyload alt="image-20220331152321558"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152205873.png" srcset="/img/loading.gif" lazyload alt="image-20220331152205873"></p>
<h4 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h4><p>​    将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中， 再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍 的内存空间。</p>
<h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><p>​    不会有内存碎片</p>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><p>​    需要占用双倍内存空间</p>
<h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3.分代垃圾回收"></a>3.分代垃圾回收</h2><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152655339.png" srcset="/img/loading.gif" lazyload alt="image-20220331152655339"></p>
<h3 id="（1）回收流程"><a href="#（1）回收流程" class="headerlink" title="（1）回收流程"></a>（1）回收流程</h3><p>新创建的对象都被放在了新生代的伊甸园中</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152718843.png" srcset="/img/loading.gif" lazyload alt="image-20220331152718843"></p>
<p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 Minor GC</p>
<p>Minor GC 会将伊甸园和幸存区FROM存活的对象先复制到 幸存区 TO中， 并让其寿命加1，再交换两个幸存 区</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152757229.png" srcset="/img/loading.gif" lazyload alt="image-20220331152757229"></p>
<p>再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC（会触发 stop the world， 暂停其他用 户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对 象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152821640.png" srcset="/img/loading.gif" lazyload alt="image-20220331152821640"></p>
<p>如果幸存区中的对象的寿命超过某个阈值（最大为15，4bit），就会被放入老年代中</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152847522.png" srcset="/img/loading.gif" lazyload alt="image-20220331152847522"></p>
<p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发Full GC，扫描新生代和老年代中所有不 再使用的对象并回收</p>
<h3 id="（2）GC分析"><a href="#（2）GC分析" class="headerlink" title="（2）GC分析"></a>（2）GC分析</h3><h4 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h4><p>​    当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代 </p>
<h4 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h4><p>​    某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行 这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运 行，进程依然正常</p>
<h3 id="（3）相关VM参数"><a href="#（3）相关VM参数" class="headerlink" title="（3）相关VM参数"></a>（3）相关VM参数</h3><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331152942849.png" srcset="/img/loading.gif" lazyload alt="image-20220331152942849"></p>
<h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h2><ul>
<li>并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。 </li>
<li>并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行， 而垃圾收集程序运行在另一个CPU上 </li>
<li>吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户 代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量 就是99%</li>
</ul>
<h3 id="（1）串行"><a href="#（1）串行" class="headerlink" title="（1）串行"></a>（1）串行</h3><ul>
<li><p>单线程 </p>
</li>
<li><p>内存较小，个人电脑（CPU核数较少）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331153400159.png" srcset="/img/loading.gif" lazyload alt="image-20220331153400159"></p>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>​    让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象 因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</p>
<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>​    Serial收集器是最基本的、发展历史最悠久的收集器</p>
<p>​    特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个CPU的环境来说， Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃 圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>​    ParNew收集器其实就是Serial收集器的多线程版本</p>
<p>​    特点：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使 用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>​    Serial Old是Serial收集器的老年代版本</p>
<p>​    特点：同样是单线程收集器，采用标记-整理算法</p>
</li>
</ul>
<h3 id="（2）吞吐量优先"><a href="#（2）吞吐量优先" class="headerlink" title="（2）吞吐量优先"></a>（2）吞吐量优先</h3><ul>
<li>多线程 </li>
<li>堆内存较大，多核CPU </li>
<li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短 </li>
<li>JDK1.8默认使用的垃圾回收器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331153719810.png" srcset="/img/loading.gif" lazyload alt="image-20220331153719810"></p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>与吞吐量关系密切，故也称为吞吐量优先收集器 </p>
<p><strong>特点</strong>：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器 （与ParNew收集器类似） </p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收 集器最重要的一个区别） </p>
<p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需 要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象 年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些 参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p> Parallel Scavenge收集器使用两个参数控制吞吐量： </p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>是Parallel Scavenge收集器的老年代版本 </p>
<p>特点：多线程，采用标记-整理算法（老年代没有幸存区）</p>
<h3 id="（3）响应时间优先"><a href="#（3）响应时间优先" class="headerlink" title="（3）响应时间优先"></a>（3）响应时间优先</h3><ul>
<li>多线程 </li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331154018638.png" srcset="/img/loading.gif" lazyload alt="image-20220331154018638"></p>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器</p>
<ul>
<li>特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片 </li>
<li>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程 序、b&#x2F;s服务</li>
</ul>
<p>CMS收集器的运行过程分为下列4步： </p>
<ul>
<li>初始标记：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题 </li>
<li>并发标记：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行 </li>
<li>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然 存在Stop The World问题 </li>
<li>并发清除：对标记的对象进行清除回收</li>
</ul>
<p>CMS收集器的内存回收过程是与用户线程一起并发执行的</p>
<h3 id="（4）G1"><a href="#（4）G1" class="headerlink" title="（4）G1"></a>（4）G1</h3><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331154338363.png" srcset="/img/loading.gif" lazyload alt="image-20220331154338363"></p>
<ul>
<li><p>定义： Garbage First</p>
</li>
<li><p>JDK 9以后默认使用，而且替代了CMS 收集器</p>
</li>
<li><p>适用场景</p>
<ul>
<li>同时注重吞吐量和低延迟（响应时间） </li>
<li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域 </li>
<li>整体上是标记-整理算法，两个区域之间是复制算法</li>
</ul>
</li>
<li><p>相关参数，JDK8 并不是默认开启的，所需要参数开启</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331154506276.png" srcset="/img/loading.gif" lazyload alt="image-20220331154506276"></p>
</li>
</ul>
<h4 id="a-G1-垃圾回收阶段"><a href="#a-G1-垃圾回收阶段" class="headerlink" title="a. G1 垃圾回收阶段"></a>a. G1 垃圾回收阶段</h4><p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161535710.png" srcset="/img/loading.gif" lazyload alt="image-20220331161535710"></p>
<p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存 ——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h4 id="b-Young-Collection"><a href="#b-Young-Collection" class="headerlink" title="b.Young Collection"></a>b.Young Collection</h4><p>分区算法region </p>
<p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控 制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<p>会STW</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161638986.png" srcset="/img/loading.gif" lazyload alt="image-20220331161638986"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161652431.png" srcset="/img/loading.gif" lazyload alt="image-20220331161652431"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161706231.png" srcset="/img/loading.gif" lazyload alt="image-20220331161706231"></p>
<h4 id="c-Young-Collection-CM"><a href="#c-Young-Collection-CM" class="headerlink" title="c.Young Collection + CM"></a>c.Young Collection + CM</h4><p>CM：并发标记</p>
<ul>
<li><p>在 Young GC 时会对 GC Root 进行初始标记 </p>
</li>
<li><p>在老年代占用堆内存的比例达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161751823.png" srcset="/img/loading.gif" lazyload alt="image-20220331161751823"></p>
</li>
</ul>
<h4 id="d-Mixed-Collection"><a href="#d-Mixed-Collection" class="headerlink" title="d.Mixed Collection"></a>d.Mixed Collection</h4><p>会对E S O 进行全面的回收</p>
<ul>
<li>最终标记 </li>
<li>拷贝存活</li>
</ul>
<p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p>
<p>为什么有的老年代被拷贝了，有的没拷贝？ </p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时 间，会回收最有价值的老年代（回收后，能够得到更多内存）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331161853706.png" srcset="/img/loading.gif" lazyload alt="image-20220331161853706"></p>
<h4 id="e-Full-GC"><a href="#e-Full-GC" class="headerlink" title="e.Full GC"></a>e.Full GC</h4><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理 </li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
<h4 id="f-Young-Collection-跨代引用"><a href="#f-Young-Collection-跨代引用" class="headerlink" title="f.Young Collection 跨代引用"></a>f.Young Collection 跨代引用</h4><p>新生代回收的跨代引用（老年代引用新生代）问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162021179.png" srcset="/img/loading.gif" lazyload alt="image-20220331162021179"></p>
<ul>
<li>卡表与Remembered Set<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡</li>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称 为脏卡</li>
</ul>
</li>
<li>在引用变更时通过post-write barried + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162129796.png" srcset="/img/loading.gif" lazyload alt="image-20220331162129796"></p>
<h4 id="g-Remark"><a href="#g-Remark" class="headerlink" title="g.Remark"></a>g.Remark</h4><p>重新标记阶段 </p>
<p>在垃圾回收时，收集器处理对象的过程中 </p>
<p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162157975.png" srcset="/img/loading.gif" lazyload alt="image-20220331162157975"></p>
<p>但是在并发标记过程中，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用 了C，这时就会用到remark</p>
<p>过程如下</p>
<ul>
<li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当 中，并将C变为 处理中 状态 </li>
<li>在并发标记阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用 引用它，就会处理它</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162244377.png" srcset="/img/loading.gif" lazyload alt="image-20220331162244377"></p>
<h4 id="h-JDK-8u20-字符串去重"><a href="#h-JDK-8u20-字符串去重" class="headerlink" title="h.JDK 8u20 字符串去重"></a>h.JDK 8u20 字符串去重</h4><p>过程</p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列 </li>
<li>当新生代回收时，G1并发检查是否有重复的字符串 </li>
<li>如果字符串的值一样，就让他们引用同一个字符串对象 </li>
<li>注意，其与String.intern的区别<ul>
<li>intern关注的是字符串对象 </li>
<li>字符串去重关注的是char[] </li>
<li>在JVM内部，使用了不同的字符串标</li>
</ul>
</li>
</ul>
<p>优点与缺点</p>
<ul>
<li>节省了大量内存 </li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h4 id="i-JDK-8u40-并发标记类卸载"><a href="#i-JDK-8u40-并发标记类卸载" class="headerlink" title="i.JDK 8u40 并发标记类卸载"></a>i.JDK 8u40 并发标记类卸载</h4><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所 加载的所有类</p>
<h4 id="j-JDK-8u60-回收巨型对象"><a href="#j-JDK-8u60-回收巨型对象" class="headerlink" title="j. JDK 8u60 回收巨型对象"></a>j. JDK 8u60 回收巨型对象</h4><ul>
<li>一个对象大于region的一半时，就称为巨型对象 </li>
<li>G1不会对巨型对象进行拷贝 </li>
<li>回收时被优先考虑 </li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收 时处理掉</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Wtaia/BlogImg/img/image-20220331162526264.png" srcset="/img/loading.gif" lazyload alt="image-20220331162526264"></p>
<h4 id="k-JDK-9-并发标记起始时间的调整"><a href="#k-JDK-9-并发标记起始时间的调整" class="headerlink" title="k.JDK 9 并发标记起始时间的调整"></a>k.JDK 9 并发标记起始时间的调整</h4><ul>
<li>并发标记必须在堆空间占满前完成，否则退化为 FullGC </li>
<li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent </li>
<li>JDK 9 可以动态调整<ul>
<li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值 </li>
<li>进行数据采样并动态调整 </li>
<li>总会添加一个安全的空档空间</li>
</ul>
</li>
</ul>
<h4 id="l-JDK-9-更高效的回收"><a href="#l-JDK-9-更高效的回收" class="headerlink" title="l.JDK 9 更高效的回收"></a>l.JDK 9 更高效的回收</h4><ul>
<li>250+增强 </li>
<li>180+bug修复 </li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/gctuning">https://docs.oracle.com/en/java/javase/12/gctuning</a></li>
</ul>
<h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5.垃圾回收调优"></a>5.垃圾回收调优</h2><p>查看虚拟机参数命令,可以根据参数去查询具体的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;D:\JAVA\JDK8.0\bin\java&quot;</span> -XX:+PrintFlagsFinal -version | findstr <span class="hljs-string">&quot;GC&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>掌握 GC 相关的 VM 参数，会基本的空间调整 </li>
<li>掌握相关工具 </li>
<li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li>
</ul>
<h3 id="（1）调优领域"><a href="#（1）调优领域" class="headerlink" title="（1）调优领域"></a>（1）调优领域</h3><ul>
<li>内存 </li>
<li>锁竞争 </li>
<li>CPU占用 </li>
<li>IO </li>
<li>GC</li>
</ul>
<h3 id="（2）确定目标"><a href="#（2）确定目标" class="headerlink" title="（2）确定目标"></a>（2）确定目标</h3><p>低延迟&#x2F;高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS G1 ZGC </li>
<li>ParallelGC </li>
<li>Zing</li>
</ul>
<h3 id="（3）最快的GC"><a href="#（3）最快的GC" class="headerlink" title="（3）最快的GC"></a>（3）最快的GC</h3><p>最快的GC是不发生GC 首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>数据是不是太多？ <ul>
<li>resultSet &#x3D; statement.executeQuery(“select * from 大表 limit n”)</li>
</ul>
</li>
<li>数据表示是否太臃肿 <ul>
<li>对象图 </li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏<ul>
<li>static Map map &#x3D; </li>
<li>软 </li>
<li>弱 </li>
<li>第三方缓存实现</li>
</ul>
</li>
</ul>
<h3 id="（4）新生代调优"><a href="#（4）新生代调优" class="headerlink" title="（4）新生代调优"></a>（4）新生代调优</h3><p>新生代的特点</p>
<ul>
<li>所有的new操作分配内存都是非常廉价的 TLAB </li>
<li>死亡对象回收零代价 </li>
<li>大部分对象用过即死（朝生夕死） </li>
<li>MInor GC 所用时间远小于Full GC</li>
</ul>
<p>新生代内存越大越好么？</p>
<ul>
<li><p>不是</p>
<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降 </li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时， 清理新生代所花费的时间会更长</li>
</ul>
</li>
<li><p>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</p>
</li>
<li><p>幸存区大到能保留【当前活跃对象+需要晋升对象】</p>
</li>
<li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:MaxTenuringThreshold=threshold<br>-XX:+PrintTenuringDistribution<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Desired survivor size 48286924 bytes, new threshold 10 (max 10)<br>- age 1: 28992024 bytes, 28992024 total<br>- age 2: 1366864 bytes, 30358888 total<br>- age 3: 1425912 bytes, 31784800 total<br>...<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="（5）老年代调优"><a href="#（5）老年代调优" class="headerlink" title="（5）老年代调优"></a>（5）老年代调优</h3><p>以 CMS 为例 </p>
<ul>
<li>CMS 的老年代内存越大越好 </li>
<li>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代 </li>
<li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:CMSInitiatingOccupancyFraction=percent<br></code></pre></td></tr></table></figure>



<h3 id="（6）案例"><a href="#（6）案例" class="headerlink" title="（6）案例"></a>（6）案例</h3><ul>
<li>案例1 Full GC 和 Minor GC频繁 </li>
<li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS） </li>
<li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/30/JAVA%E5%9F%BA%E7%A1%80/">
                        <span class="hidden-mobile">JAVA基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
